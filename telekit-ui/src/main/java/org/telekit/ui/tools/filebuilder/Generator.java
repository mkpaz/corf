package org.telekit.ui.tools.filebuilder;

import org.telekit.base.domain.Encoding;
import org.telekit.base.domain.LineSeparator;
import org.telekit.base.domain.exception.TelekitException;
import org.telekit.base.i18n.Messages;
import org.telekit.ui.tools.common.Param;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.*;

import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.apache.commons.lang3.StringUtils.trim;
import static org.telekit.base.util.CollectionUtils.ensureNotNull;
import static org.telekit.base.util.PlaceholderReplacer.containsPlaceholders;
import static org.telekit.base.util.PlaceholderReplacer.format;
import static org.telekit.ui.MessageKeys.*;
import static org.telekit.ui.tools.common.ReplacementUtils.*;

public class Generator implements Runnable {

    public static final int MAX_CSV_SIZE = 100000;
    public static final int MODE_REPLACE = 0;
    public static final int MODE_APPEND = 1;

    private final Template template;
    private final String[][] csv;
    private final File outputFile;

    private String lineSeparator = System.lineSeparator();
    private Charset charset = StandardCharsets.UTF_8;
    private boolean bom = false;
    private int mode = MODE_REPLACE;

    public Generator(Template template, String[][] csv, File outputFile) {
        Objects.requireNonNull(template);
        Objects.requireNonNull(csv);
        Objects.requireNonNull(outputFile);

        this.template = new Template(template);
        this.csv = csv;
        this.outputFile = outputFile;
    }

    public void setLineSeparator(String lineSeparator) {
        this.lineSeparator = lineSeparator;
    }

    public void setMode(int mode) {
        this.mode = mode;
    }

    public void setCharset(Charset charset, boolean bom) {
        this.charset = charset;
        this.bom = bom;
    }

    @Override
    public void run() {
        Map<String, String> replacements = new HashMap<>();
        Set<Param> params = ensureNotNull(template.getParams());

        try (FileOutputStream fos = new FileOutputStream(outputFile, mode == MODE_APPEND);
             OutputStreamWriter osw = new OutputStreamWriter(fos, charset);
             BufferedWriter out = new BufferedWriter(osw)) {

            // write BOM for new files if specified
            if (bom && mode != MODE_APPEND) out.write(Encoding.BOM);

            // write header
            if (isNotBlank(template.getHeader())) {
                String header = forceLineSeparator(trim(template.getHeader()), lineSeparator);
                out.write(header);
                out.write(lineSeparator);
            }

            // write pattern
            String pattern = forceLineSeparator(trim(template.getPattern()), lineSeparator);
            for (int rowIndex = 0; rowIndex < csv.length & rowIndex < MAX_CSV_SIZE; rowIndex++) {
                String[] row = csv[rowIndex];

                // update all placeholders values
                putTemplatePlaceholders(replacements, params);
                putIndexPlaceholders(replacements, rowIndex);
                putCsvPlaceholders(replacements, row);

                out.write(format(pattern, replacements));
                out.write(lineSeparator);
            }

            // write footer
            if (isNotBlank(template.getFooter())) {
                String footer = forceLineSeparator(trim(template.getFooter()), lineSeparator);
                out.write(footer);
                out.write(lineSeparator);
            }
        } catch (Exception e) {
            throw new TelekitException(Messages.get(MSG_GENERIC_IO_ERROR), e);
        }
    }

    public static List<String> validate(Template template, String[][] csv) {
        Set<Param> params = ensureNotNull(template.getParams());
        Map<String, String> replacements = new HashMap<>();
        List<String> warnings = new ArrayList<>();

        // verify max size
        if (csv.length > MAX_CSV_SIZE) {
            warnings.add(Messages.get(TOOLS_MSG_VALIDATION_CSV_THRESHOLD_EXCEEDED, MAX_CSV_SIZE));
        }

        // verify that all non-autogenerated params values has been specified
        boolean hasBlankValues = putTemplatePlaceholders(replacements, params);
        if (hasBlankValues) warnings.add(Messages.get(TOOLS_MSG_VALIDATION_BLANK_PARAM_VALUES));

        int firstRowSize = 0, maxRowSize = 0;
        String firstLineAfterFormatting = "";
        for (int rowIndex = 0; rowIndex < csv.length & rowIndex < MAX_CSV_SIZE; rowIndex++) {
            String[] row = csv[rowIndex];
            if (rowIndex == 0) {
                firstRowSize = maxRowSize = row.length;
                // unresolved placeholders validation can be performed for the first line only
                putIndexPlaceholders(replacements, rowIndex);
                putCsvPlaceholders(replacements, row);
                firstLineAfterFormatting = format(template.getPattern(), replacements);
            } else {
                maxRowSize = row.length;
            }
        }

        // verify that all csv table rows has the same columns count
        if (firstRowSize != maxRowSize) warnings.add(Messages.get(TOOLS_MSG_VALIDATION_MIXED_CSV));

        // verify that all placeholders has been replaced
        if (containsPlaceholders(firstLineAfterFormatting)) {
            warnings.add(Messages.get(TOOLS_MSG_VALIDATION_UNRESOLVED_PLACEHOLDERS));
        }

        return warnings;
    }

    private static String forceLineSeparator(String text, String lineSeparator) {
        return String.join(lineSeparator, text.split(LineSeparator.LINE_SPLIT_PATTERN));
    }
}
