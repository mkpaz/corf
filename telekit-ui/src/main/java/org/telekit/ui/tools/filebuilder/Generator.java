package org.telekit.ui.tools.filebuilder;

import org.telekit.base.domain.Encoding;
import org.telekit.base.domain.LineSeparator;
import org.telekit.base.domain.TelekitException;
import org.telekit.base.i18n.Messages;
import org.telekit.base.util.PlaceholderReplacer;
import org.telekit.ui.tools.common.Param;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.*;

import static org.apache.commons.lang3.StringUtils.*;
import static org.telekit.base.util.CollectionUtils.ensureNotNull;
import static org.telekit.base.util.NumberUtils.ensureRange;
import static org.telekit.base.util.PasswordGenerator.ASCII_LOWER_UPPER_DIGITS;
import static org.telekit.base.util.PasswordGenerator.random;
import static org.telekit.ui.MessageKeys.*;
import static org.telekit.ui.tools.common.Param.*;

public class Generator implements Runnable {

    public static final int MAX_CSV_SIZE = 100000;

    private final Template template;
    private final String[][] csv;
    private final File outputFile;

    private String lineSeparator = System.lineSeparator();
    private boolean append = false;
    private Charset charset = StandardCharsets.UTF_8;
    private boolean bom = false;

    public Generator(Template template, String[][] csv, File outputFile) {
        this.template = new Template(template);
        this.csv = csv;
        this.outputFile = outputFile;
    }

    @Override
    public void run() {
        Map<String, String> replacements = new HashMap<>();
        Set<Param> params = ensureNotNull(template.getParams());

        try (FileOutputStream fos = new FileOutputStream(outputFile, append);
             OutputStreamWriter osw = new OutputStreamWriter(fos, charset);
             BufferedWriter out = new BufferedWriter(osw)) {

            if (bom && !append) out.write(Encoding.BOM);

            if (isNotBlank(template.getHeader())) {
                String header = forceLineSeparator(trim(template.getHeader()), lineSeparator);
                out.write(header);
                out.write(lineSeparator);
            }

            String pattern = forceLineSeparator(trim(template.getPattern()), lineSeparator);
            for (int rowIndex = 0; rowIndex < csv.length & rowIndex < MAX_CSV_SIZE; rowIndex++) {
                String[] row = csv[rowIndex];
                putTemplateParams(replacements, params); // autogenerated params need to be updated too
                putIndexParams(replacements, rowIndex);
                putCsvParams(replacements, row, rowIndex);

                out.write(PlaceholderReplacer.format(pattern, replacements));
                out.write(lineSeparator);
            }

            if (isNotBlank(template.getFooter())) {
                String footer = forceLineSeparator(trim(template.getFooter()), lineSeparator);
                out.write(footer);
                out.write(lineSeparator);
            }
        } catch (Exception e) {
            throw new TelekitException(Messages.get(MSG_GENERIC_IO_ERROR), e);
        }
    }

    public static List<String> validate(Template template, String[][] csv) {
        Set<Param> params = ensureNotNull(template.getParams());
        Map<String, String> replacements = new HashMap<>();
        List<String> warnings = new ArrayList<>();

        if (csv.length > MAX_CSV_SIZE) {
            warnings.add(Messages.get(TOOLS_MSG_VALIDATION_CSV_THRESHOLD_EXCEEDED, MAX_CSV_SIZE));
        }

        // check that all non-autogenerated params values has been specified
        boolean warnBlankValues = putTemplateParams(replacements, params);
        if (warnBlankValues) {
            warnings.add(Messages.get(TOOLS_MSG_VALIDATION_BLANK_PARAM_VALUES));
        }

        int firstRowSize = 0;
        int peekRowSize = 0;
        String firstLineAfterReplacements = "";

        for (int rowIndex = 0; rowIndex < csv.length & rowIndex < MAX_CSV_SIZE; rowIndex++) {
            String[] row = csv[rowIndex];
            if (rowIndex == 0) {
                firstRowSize = peekRowSize = row.length;

                putIndexParams(replacements, rowIndex);
                putCsvParams(replacements, row, rowIndex);

                firstLineAfterReplacements = PlaceholderReplacer.format(template.getPattern(), replacements);
            } else {
                peekRowSize = row.length;
            }
        }

        // check that all csv table rows has the same columns count
        if (firstRowSize != peekRowSize) {
            warnings.add(Messages.get(TOOLS_MSG_VALIDATION_MIXED_CSV));
        }

        // check that all placeholders has been replaced
        if (PlaceholderReplacer.containsPlaceholders(firstLineAfterReplacements)) {
            warnings.add(Messages.get(TOOLS_MSG_VALIDATION_UNRESOLVED_PLACEHOLDERS));
        }

        return warnings;
    }

    private static boolean putTemplateParams(Map<String, String> accumulator, Set<Param> params) {
        boolean hasBlankValues = false;
        for (Param param : params) {
            // put params into replacements even if param value is empty
            // because it might not be an error but intended behavior
            switch (param.getType()) {
                case CONSTANT -> accumulator.put(
                        param.getName(),
                        defaultString(param.getValue(), "")
                );
                case PASSWORD -> accumulator.put(
                        param.getName(),
                        generatePassword(param.getLength())
                );
                case PASSWORD_BASE64 -> accumulator.put(
                        param.getName(),
                        new String(Base64.getEncoder().encode(generatePassword(param.getLength()).getBytes()))
                );
                case UUID -> accumulator.put(
                        param.getName(),
                        UUID.randomUUID().toString()
                );
            }
            if (!param.isAutoGenerated() && isBlank(param.getValue())) {
                hasBlankValues = true;
            }
        }
        return hasBlankValues;
    }

    private static void putCsvParams(Map<String, String> accumulator, String[] row, int rowIndex) {
        for (int index = 0; index < row.length; index++) {
            accumulator.put("_csv" + index, row[index]);
        }
    }

    private static void putIndexParams(Map<String, String> accumulator, int sequentialIndex) {
        accumulator.put("_index0", String.valueOf(sequentialIndex));
        accumulator.put("_index1", String.valueOf(sequentialIndex + 1));
    }

    private static String generatePassword(int length) {
        return random(
                ensureRange(length, MIN_PASSWORD_LENGTH, MAX_PASSWORD_LENGTH, DEFAULT_PASSWORD_LENGTH),
                ASCII_LOWER_UPPER_DIGITS
        );
    }

    private static String forceLineSeparator(String text, String lineSeparator) {
        return String.join(lineSeparator, text.split(LineSeparator.LINE_SPLIT_PATTERN));
    }

    public void setLineSeparator(String lineSeparator) {
        this.lineSeparator = lineSeparator;
    }

    public void setAppend(boolean append) {
        this.append = append;
    }

    public void setCharset(Charset charset) {
        this.charset = charset;
    }

    public void setBom(boolean bom) {
        this.bom = bom;
    }
}
