package org.telekit.ui.tools.import_file_builder;

import org.telekit.base.domain.TelekitException;
import org.telekit.base.util.FileUtils;
import org.telekit.base.util.PlaceholderReplacer;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.*;

import static org.apache.commons.lang3.StringUtils.*;
import static org.telekit.base.util.CollectionUtils.nullToEmpty;
import static org.telekit.base.util.NumberUtils.ensureRange;
import static org.telekit.base.util.PasswordGenerator.ASCII_LOWER_UPPER_DIGITS;
import static org.telekit.base.util.PasswordGenerator.random;
import static org.telekit.ui.service.Messages.Keys.MSG_GENERIC_IO_ERROR;
import static org.telekit.ui.service.Messages.getMessage;
import static org.telekit.ui.tools.import_file_builder.Param.*;

public class Generator implements Runnable {

    public static final int MAX_CSV_SIZE = 100000;

    private final Template template;
    private final String[][] csv;
    private final File outputFile;

    private String lineSeparator = System.lineSeparator();
    private boolean append = false;
    private String charsetName = StandardCharsets.UTF_8.name();
    private boolean bom = false;

    public Generator(Template template, String[][] csv, File outputFile) {
        this.template = new Template(template);
        this.csv = csv;
        this.outputFile = outputFile;
    }

    @Override
    public void run() {
        Map<String, String> replacements = new HashMap<>();
        Set<Param> params = nullToEmpty(template.getParams());

        try (FileOutputStream fos = new FileOutputStream(outputFile, append);
             OutputStreamWriter osw = new OutputStreamWriter(fos, charsetName);
             BufferedWriter out = new BufferedWriter(osw)) {

            if (bom && !append) out.write(FileUtils.BOM);

            if (isNotBlank(template.getHeader())) {
                String header = forceLineSeparator(trim(template.getHeader()), lineSeparator);
                out.write(header);
                out.write(lineSeparator);
            }

            String pattern = forceLineSeparator(trim(template.getPattern()), lineSeparator);
            for (int rowIndex = 0; rowIndex < csv.length & rowIndex < MAX_CSV_SIZE; rowIndex++) {
                String[] row = csv[rowIndex];
                putTemplateParams(replacements, params); // autogenerated params need to be updated too
                putIndexParams(replacements, rowIndex);
                putCsvParams(replacements, row, rowIndex);

                out.write(PlaceholderReplacer.format(pattern, replacements));
                out.write(lineSeparator);
            }

            if (isNotBlank(template.getFooter())) {
                String footer = forceLineSeparator(trim(template.getFooter()), lineSeparator);
                out.write(footer);
                out.write(lineSeparator);
            }
        } catch (Exception e) {
            throw new TelekitException(getMessage(MSG_GENERIC_IO_ERROR), e);
        }
    }

    public static List<Warning> validate(Template template, String[][] csv) {
        Set<Param> params = nullToEmpty(template.getParams());
        Map<String, String> replacements = new HashMap<>();
        List<Warning> warnings = new ArrayList<>();

        if (csv.length > MAX_CSV_SIZE) {
            warnings.add(Warning.CSV_THRESHOLD_EXCEEDED);
        }

        // check that all non-autogenerated params values has been specified
        boolean warnBlankValues = putTemplateParams(replacements, params);
        if (warnBlankValues) {
            warnings.add(Warning.BLANK_LINES);
        }

        int firstRowSize = 0;
        int peekRowSize = 0;
        String firstPatternAfterReplacements = "";

        for (int rowIndex = 0; rowIndex < csv.length & rowIndex < MAX_CSV_SIZE; rowIndex++) {
            String[] row = csv[rowIndex];
            if (rowIndex == 0) {
                firstRowSize = peekRowSize = row.length;

                putIndexParams(replacements, rowIndex);
                putCsvParams(replacements, row, rowIndex);

                firstPatternAfterReplacements = PlaceholderReplacer.format(template.getPattern(), replacements);
            } else {
                peekRowSize = row.length;
            }
        }

        // check that all csv table rows has the same columns count
        if (firstRowSize != peekRowSize) {
            warnings.add(Warning.MIXED_CSV_SIZE);
        }

        // check that all placeholders has been replaced
        if (PlaceholderReplacer.containsPlaceholders(firstPatternAfterReplacements)) {
            warnings.add(Warning.UNRESOLVED_PLACEHOLDERS);
        }

        return warnings;
    }

    private static boolean putTemplateParams(Map<String, String> accumulator, Set<Param> params) {
        boolean hasBlankValues = false;
        for (Param param : params) {
            switch (param.getType()) {
                case CONSTANT:
                    // put params into replacements even if param value is empty
                    // because it might not be an error but intended behavior
                    accumulator.put(
                            param.getName(),
                            defaultString(param.getValue(), "")
                    );
                    break;
                case PASSWORD:
                    accumulator.put(
                            param.getName(),
                            generatePassword(param.getLength())
                    );
                    break;
                case PASSWORD_BASE64:
                    accumulator.put(
                            param.getName(),
                            new String(Base64.getEncoder().encode(generatePassword(param.getLength()).getBytes()))
                    );
                    break;
                case UUID:
                    accumulator.put(param.getName(), UUID.randomUUID().toString());
                    break;
            }
            if (!param.isAutoGenerated() && isBlank(param.getValue())) {
                hasBlankValues = true;
            }
        }
        return hasBlankValues;
    }

    private static void putCsvParams(Map<String, String> accumulator, String[] row, int rowIndex) {
        for (int index = 0; index < row.length; index++) {
            accumulator.put("_csv" + index, row[index]);
        }
    }

    private static void putIndexParams(Map<String, String> accumulator, int sequentialIndex) {
        accumulator.put("_index0", String.valueOf(sequentialIndex));
        accumulator.put("_index1", String.valueOf(sequentialIndex + 1));
    }

    private static String generatePassword(int length) {
        return random(
                ensureRange(length, MIN_PASSWORD_LENGTH, MAX_PASSWORD_LENGTH, DEFAULT_PASSWORD_LENGTH),
                ASCII_LOWER_UPPER_DIGITS
        );
    }

    private static String forceLineSeparator(String text, String lineSeparator) {
        return String.join(lineSeparator, text.split(FileUtils.EOL_SPLIT_PATTERN));
    }

    ///////////////////////////////////////////////////////////////////////////

    public void setLineSeparator(String lineSeparator) {
        this.lineSeparator = lineSeparator;
    }

    public void setAppend(boolean append) {
        this.append = append;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public void setBom(boolean bom) {
        this.bom = bom;
    }

    public enum Warning {
        BLANK_LINES,
        MIXED_CSV_SIZE,
        UNRESOLVED_PLACEHOLDERS,
        CSV_THRESHOLD_EXCEEDED
    }
}
